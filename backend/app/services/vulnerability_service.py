import httpx
import asyncio
from typing import Dict, List, Optional
from fastapi import HTTPException
import os
import json
import random
from datetime import datetime

class VulnerabilityService:
    def __init__(self):
        # Configuration des APIs
        self.jba_base_url = "https://api.jbarisk.com/v1"
        self.fema_base_url = "https://api.fema.gov/v1"
        
        # Clés API (à configurer)
        self.jba_api_key = os.getenv("JBA_API_KEY")
        self.fema_api_key = os.getenv("FEMA_API_KEY")
        
        # Vérifier la configuration
        if not self.jba_api_key or self.jba_api_key == "your_jba_api_key_here":
            print("⚠️  JBA_API_KEY non configurée - Utilisation des données par défaut")
            self.jba_api_key = None
            
        if not self.fema_api_key or self.fema_api_key == "your_fema_api_key_here":
            print("⚠️  FEMA_API_KEY non configurée - Utilisation des données par défaut")
            self.fema_api_key = None

    async def get_jba_vulnerability_data(self, latitude: float, longitude: float) -> Dict:
        """Récupérer les données de vulnérabilité JBA Risk Management"""
        if not self.jba_api_key:
            return self._get_default_jba_data(latitude, longitude)

        try:
            async with httpx.AsyncClient() as client:
                url = f"{self.jba_base_url}/vulnerability"
                params = {
                    "lat": latitude,
                    "lon": longitude,
                    "api_key": self.jba_api_key,
                    "format": "json"
                }
                
                response = await client.get(url, params=params, timeout=10.0)
                response.raise_for_status()
                
                return response.json()

        except httpx.HTTPStatusError as e:
            print(f"⚠️  Erreur API JBA: {e.response.status_code} - Utilisation des données par défaut")
            return self._get_default_jba_data(latitude, longitude)
        except Exception as e:
            print(f"⚠️  Erreur lors de la récupération JBA: {str(e)} - Utilisation des données par défaut")
            return self._get_default_jba_data(latitude, longitude)

    async def get_fema_vulnerability_data(self, latitude: float, longitude: float) -> Dict:
        """Récupérer les données de vulnérabilité FEMA"""
        if not self.fema_api_key:
            return self._get_default_fema_data(latitude, longitude)

        try:
            async with httpx.AsyncClient() as client:
                url = f"{self.fema_base_url}/vulnerability"
                params = {
                    "lat": latitude,
                    "lon": longitude,
                    "api_key": self.fema_api_key,
                    "format": "json"
                }
                
                response = await client.get(url, params=params, timeout=10.0)
                response.raise_for_status()
                
                return response.json()

        except httpx.HTTPStatusError as e:
            print(f"⚠️  Erreur API FEMA: {e.response.status_code} - Utilisation des données par défaut")
            return self._get_default_fema_data(latitude, longitude)
        except Exception as e:
            print(f"⚠️  Erreur lors de la récupération FEMA: {str(e)} - Utilisation des données par défaut")
            return self._get_default_fema_data(latitude, longitude)

    def _get_default_jba_data(self, latitude: float, longitude: float) -> Dict:
        """Générer des données JBA par défaut basées sur la localisation"""
        # Déterminer la zone de vulnérabilité basée sur les coordonnées
        vulnerability_factors = self._calculate_vulnerability_factors(latitude, longitude)
        
        return {
            "flood_risk": {
                "probability": vulnerability_factors["flood_probability"],
                "depth": vulnerability_factors["flood_depth"],
                "frequency": vulnerability_factors["flood_frequency"],
                "zone_type": vulnerability_factors["flood_zone"]
            },
            "earthquake_risk": {
                "probability": vulnerability_factors["earthquake_probability"],
                "magnitude": vulnerability_factors["earthquake_magnitude"],
                "frequency": vulnerability_factors["earthquake_frequency"],
                "zone_type": vulnerability_factors["earthquake_zone"]
            },
            "wind_risk": {
                "probability": vulnerability_factors["wind_probability"],
                "speed": vulnerability_factors["wind_speed"],
                "frequency": vulnerability_factors["wind_frequency"],
                "zone_type": vulnerability_factors["wind_zone"]
            },
            "subsidence_risk": {
                "probability": vulnerability_factors["subsidence_probability"],
                "severity": vulnerability_factors["subsidence_rate"], # Changed from subsidence_severity to subsidence_rate
                "frequency": vulnerability_factors["subsidence_frequency"],
                "zone_type": vulnerability_factors["subsidence_zone"]
            }
        }

    def _get_default_fema_data(self, latitude: float, longitude: float) -> Dict:
        """Générer des données FEMA par défaut"""
        vulnerability_factors = self._calculate_vulnerability_factors(latitude, longitude)
        
        return {
            "natural_hazards": {
                "flood": {
                    "risk_level": vulnerability_factors["flood_zone"],
                    "probability": vulnerability_factors["flood_probability"],
                    "impact": vulnerability_factors["flood_impact"]
                },
                "hurricane": {
                    "risk_level": vulnerability_factors["hurricane_zone"],
                    "probability": vulnerability_factors["hurricane_probability"],
                    "impact": vulnerability_factors["hurricane_impact"]
                },
                "earthquake": {
                    "risk_level": vulnerability_factors["earthquake_zone"],
                    "probability": vulnerability_factors["earthquake_probability"],
                    "impact": vulnerability_factors["earthquake_impact"]
                },
                "wildfire": {
                    "risk_level": vulnerability_factors["wildfire_zone"],
                    "probability": vulnerability_factors["wildfire_probability"],
                    "impact": vulnerability_factors["wildfire_impact"]
                }
            },
            "infrastructure_vulnerability": {
                "roads": vulnerability_factors["road_vulnerability"],
                "utilities": vulnerability_factors["utility_vulnerability"],
                "buildings": vulnerability_factors["building_vulnerability"]
            }
        }

    def _calculate_vulnerability_factors(self, latitude: float, longitude: float) -> Dict:
        """Calculer les facteurs de vulnérabilité basés sur la localisation"""
        # Utiliser les coordonnées comme seed pour la cohérence
        base_seed = int(latitude * 1000 + longitude * 1000)
        random.seed(base_seed)
        
        # Déterminer la zone géographique avec des variations plus importantes
        if 43.0 <= latitude <= 51.0 and -5.0 <= longitude <= 10.0:  # France métropolitaine
            if latitude > 48.0:  # Nord de la France
                flood_probability = random.uniform(0.5, 0.8)
                earthquake_probability = random.uniform(0.02, 0.08)
                wind_probability = random.uniform(0.6, 0.9)
                subsidence_probability = random.uniform(0.15, 0.4)
            elif latitude > 45.0:  # Centre de la France
                flood_probability = random.uniform(0.3, 0.6)
                earthquake_probability = random.uniform(0.15, 0.35)
                wind_probability = random.uniform(0.4, 0.7)
                subsidence_probability = random.uniform(0.25, 0.5)
            else:  # Sud de la France
                flood_probability = random.uniform(0.2, 0.5)
                earthquake_probability = random.uniform(0.25, 0.45)
                wind_probability = random.uniform(0.3, 0.6)
                subsidence_probability = random.uniform(0.35, 0.6)
        else:
            # Autres pays - données génériques
            flood_probability = random.uniform(0.15, 0.4)
            earthquake_probability = random.uniform(0.08, 0.25)
            wind_probability = random.uniform(0.25, 0.55)
            subsidence_probability = random.uniform(0.15, 0.35)
        
        return {
            "flood_probability": flood_probability,
            "flood_depth": random.uniform(0.5, 3.0),
            "flood_frequency": random.uniform(0.1, 0.4),
            "flood_zone": self._get_zone_type(flood_probability),
            
            "earthquake_probability": earthquake_probability,
            "earthquake_magnitude": random.uniform(3.0, 6.5),
            "earthquake_frequency": random.uniform(0.05, 0.2),
            "earthquake_zone": self._get_zone_type(earthquake_probability),
            
            "wind_probability": wind_probability,
            "wind_speed": random.uniform(20.0, 50.0),
            "wind_frequency": random.uniform(0.2, 0.5),
            "wind_zone": self._get_zone_type(wind_probability),
            
            "subsidence_probability": subsidence_probability,
            "subsidence_rate": random.uniform(0.1, 2.0),
            "subsidence_frequency": random.uniform(0.05, 0.2),
            "subsidence_zone": self._get_zone_type(subsidence_probability)
        }
    
    def _get_zone_type(self, probability: float) -> str:
        """Déterminer le type de zone basé sur la probabilité"""
        if probability < 0.2:
            return "faible"
        elif probability < 0.4:
            return "modérée"
        else:
            return "élevée"

    def calculate_vulnerability_risk(self, jba_data: Dict, fema_data: Dict, site_type: str, site_value: float) -> Dict:
        """Calculer un score de vulnérabilité basé sur les données JBA et FEMA"""
        try:
            # Extraire les données de vulnérabilité
            flood_risk = jba_data.get("flood_risk", {})
            earthquake_risk = jba_data.get("earthquake_risk", {})
            wind_risk = jba_data.get("wind_risk", {})
            subsidence_risk = jba_data.get("subsidence_risk", {})
            
            natural_hazards = fema_data.get("natural_hazards", {})
            infrastructure = fema_data.get("infrastructure_vulnerability", {})
            
            # Calculer les scores de risque par catégorie
            flood_score = self._calculate_flood_vulnerability(flood_risk, natural_hazards.get("flood", {}))
            earthquake_score = self._calculate_earthquake_vulnerability(earthquake_risk, natural_hazards.get("earthquake", {}))
            wind_score = self._calculate_wind_vulnerability(wind_risk, natural_hazards.get("hurricane", {}))
            subsidence_score = self._calculate_subsidence_vulnerability(subsidence_risk)
            infrastructure_score = self._calculate_infrastructure_vulnerability(infrastructure)
            
            # Facteur de type de site
            site_type_multiplier = {
                "résidentiel": 1.0,
                "commercial": 1.1,
                "industriel": 1.3,
                "agricole": 1.2,
                "public": 1.0,
                "logistique": 1.2
            }.get(site_type.lower(), 1.0)
            
            # Calculer le score de vulnérabilité global
            vulnerability_risk = (
                flood_score * 0.25 +
                earthquake_score * 0.20 +
                wind_score * 0.20 +
                subsidence_score * 0.15 +
                infrastructure_score * 0.20
            ) * site_type_multiplier
            
            return {
                "vulnerability_risk_score": min(100.0, max(0.0, vulnerability_risk)),
                "risk_factors": {
                    "flood_vulnerability": flood_score,
                    "earthquake_vulnerability": earthquake_score,
                    "wind_vulnerability": wind_score,
                    "subsidence_vulnerability": subsidence_score,
                    "infrastructure_vulnerability": infrastructure_score,
                    "site_type_multiplier": site_type_multiplier
                },
                "zone_assessments": {
                    "flood_zone": flood_risk.get("zone_type", "inconnue"),
                    "earthquake_zone": earthquake_risk.get("zone_type", "inconnue"),
                    "wind_zone": wind_risk.get("zone_type", "inconnue"),
                    "subsidence_zone": subsidence_risk.get("zone_type", "inconnue")
                }
            }
            
        except Exception as e:
            print(f"Erreur lors du calcul de la vulnérabilité: {e}")
            return {
                "vulnerability_risk_score": 25.0,
                "risk_factors": {
                    "flood_vulnerability": 20.0,
                    "earthquake_vulnerability": 15.0,
                    "wind_vulnerability": 20.0,
                    "subsidence_vulnerability": 10.0,
                    "infrastructure_vulnerability": 25.0,
                    "site_type_multiplier": 1.0
                },
                "zone_assessments": {
                    "flood_zone": "inconnue",
                    "earthquake_zone": "inconnue",
                    "wind_zone": "inconnue",
                    "subsidence_zone": "inconnue"
                }
            }

    def _calculate_flood_vulnerability(self, jba_flood: Dict, fema_flood: Dict) -> float:
        """Calculer la vulnérabilité aux inondations"""
        probability = jba_flood.get("probability", 0.2)
        depth = jba_flood.get("depth", 1.0)
        zone_type = jba_flood.get("zone_type", "modérée")
        
        # Score basé sur la probabilité et la profondeur
        base_score = probability * 50 + (depth / 3.0) * 30
        
        # Ajustement selon la zone
        zone_multiplier = {"faible": 0.7, "modérée": 1.0, "élevée": 1.3}.get(zone_type, 1.0)
        
        return min(100.0, base_score * zone_multiplier)

    def _calculate_earthquake_vulnerability(self, jba_earthquake: Dict, fema_earthquake: Dict) -> float:
        """Calculer la vulnérabilité aux séismes"""
        probability = jba_earthquake.get("probability", 0.1)
        magnitude = jba_earthquake.get("magnitude", 4.0)
        zone_type = jba_earthquake.get("zone_type", "faible")
        
        # Score basé sur la probabilité et la magnitude
        base_score = probability * 40 + (magnitude - 3.0) * 15
        
        # Ajustement selon la zone
        zone_multiplier = {"faible": 0.6, "modérée": 1.0, "élevée": 1.4}.get(zone_type, 1.0)
        
        return min(100.0, base_score * zone_multiplier)

    def _calculate_wind_vulnerability(self, jba_wind: Dict, fema_hurricane: Dict) -> float:
        """Calculer la vulnérabilité au vent"""
        probability = jba_wind.get("probability", 0.3)
        speed = jba_wind.get("speed", 80)
        zone_type = jba_wind.get("zone_type", "modérée")
        
        # Score basé sur la probabilité et la vitesse
        base_score = probability * 40 + (speed - 60) / 60 * 30
        
        # Ajustement selon la zone
        zone_multiplier = {"faible": 0.7, "modérée": 1.0, "élevée": 1.3}.get(zone_type, 1.0)
        
        return min(100.0, base_score * zone_multiplier)

    def _calculate_subsidence_vulnerability(self, jba_subsidence: Dict) -> float:
        """Calculer la vulnérabilité à l'affaissement"""
        probability = jba_subsidence.get("probability", 0.1)
        severity = jba_subsidence.get("severity", "faible")
        zone_type = jba_subsidence.get("zone_type", "faible")
        
        # Score basé sur la probabilité
        base_score = probability * 60
        
        # Ajustement selon la sévérité
        severity_multiplier = {"faible": 0.5, "modérée": 1.0, "élevée": 1.5}.get(severity, 1.0)
        zone_multiplier = {"faible": 0.6, "modérée": 1.0, "élevée": 1.4}.get(zone_type, 1.0)
        
        return min(100.0, base_score * severity_multiplier * zone_multiplier)

    def _calculate_infrastructure_vulnerability(self, infrastructure: Dict) -> float:
        """Calculer la vulnérabilité des infrastructures"""
        roads = infrastructure.get("roads", 0.3)
        utilities = infrastructure.get("utilities", 0.4)
        buildings = infrastructure.get("buildings", 0.3)
        
        # Score moyen des vulnérabilités d'infrastructure
        return (roads + utilities + buildings) * 100

    async def get_vulnerability_risk_for_site(self, latitude: float, longitude: float, site_type: str, site_value: float) -> Dict:
        """Récupérer le risque de vulnérabilité pour un site"""
        try:
            # Récupérer les données JBA
            jba_data = await self.get_jba_vulnerability_data(latitude, longitude)
            
            # Récupérer les données FEMA
            fema_data = await self.get_fema_vulnerability_data(latitude, longitude)
            
            # Calculer le risque
            risk_assessment = self.calculate_vulnerability_risk(jba_data, fema_data, site_type, site_value)
            
            return {
                "jba_data": jba_data,
                "fema_data": fema_data,
                "vulnerability_risk": risk_assessment
            }
            
        except Exception as e:
            print(f"Erreur lors de la récupération du risque de vulnérabilité: {e}")
            return {
                "jba_data": {},
                "fema_data": {},
                "vulnerability_risk": {
                    "vulnerability_risk_score": 25.0,
                    "risk_factors": {
                        "flood_vulnerability": 20.0,
                        "earthquake_vulnerability": 15.0,
                        "wind_vulnerability": 20.0,
                        "subsidence_vulnerability": 10.0,
                        "infrastructure_vulnerability": 25.0,
                        "site_type_multiplier": 1.0
                    },
                    "zone_assessments": {
                        "flood_zone": "inconnue",
                        "earthquake_zone": "inconnue",
                        "wind_zone": "inconnue",
                        "subsidence_zone": "inconnue"
                    }
                }
            }

# Instance globale du service
vulnerability_service = VulnerabilityService() 