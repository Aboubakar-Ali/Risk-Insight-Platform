from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Dict
from app.core.database import get_db
from app.services.vulnerability_service import vulnerability_service

router = APIRouter()

@router.get("/site/{site_id}")
async def get_vulnerability_risk_for_site(site_id: int, db: Session = Depends(get_db)):
    """Récupérer le risque de vulnérabilité pour un site spécifique"""
    from app.models.site import Site
    
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Site non trouvé"
        )
    
    try:
        vulnerability_risk = await vulnerability_service.get_vulnerability_risk_for_site(
            site.latitude,
            site.longitude,
            site.building_type.value,
            site.building_value
        )
        
        return {
            "site_id": site_id,
            "site_name": site.name,
            "location": f"{site.city}, {site.country}",
            "coordinates": {
                "latitude": site.latitude,
                "longitude": site.longitude
            },
            "vulnerability_risk": vulnerability_risk
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erreur lors de la récupération du risque de vulnérabilité: {str(e)}"
        )

@router.get("/zones/{site_id}")
async def get_vulnerability_zones(site_id: int, db: Session = Depends(get_db)):
    """Récupérer les zones de vulnérabilité pour un site"""
    from app.models.site import Site
    
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Site non trouvé"
        )
    
    try:
        vulnerability_risk = await vulnerability_service.get_vulnerability_risk_for_site(
            site.latitude,
            site.longitude,
            site.building_type.value,
            site.building_value
        )
        
        zones = vulnerability_risk.get("vulnerability_risk", {}).get("zone_assessments", {})
        risk_factors = vulnerability_risk.get("vulnerability_risk", {}).get("risk_factors", {})
        
        return {
            "site_id": site_id,
            "site_name": site.name,
            "vulnerability_zones": zones,
            "risk_factors": risk_factors,
            "jba_data": vulnerability_risk.get("jba_data", {}),
            "fema_data": vulnerability_risk.get("fema_data", {})
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erreur lors de la récupération des zones: {str(e)}"
        )

@router.post("/update-all-sites")
async def update_all_sites_vulnerability_risk(db: Session = Depends(get_db)):
    """Mettre à jour les scores de vulnérabilité pour tous les sites"""
    from app.models.site import Site
    
    try:
        sites = db.query(Site).all()
        updated_sites = []
        
        for site in sites:
            try:
                vulnerability_risk = await vulnerability_service.get_vulnerability_risk_for_site(
                    site.latitude,
                    site.longitude,
                    site.building_type.value,
                    site.building_value
                )
                
                # Mettre à jour le score de risque avec les données de vulnérabilité
                vulnerability_score = vulnerability_risk.get("vulnerability_risk", {}).get("vulnerability_risk_score", 25.0)
                
                # Calculer un nouveau score global (moyenne avec l'existant)
                new_risk_score = (site.risk_score + vulnerability_score) / 2
                site.risk_score = new_risk_score
                
                zones = vulnerability_risk.get("vulnerability_risk", {}).get("zone_assessments", {})
                
                updated_sites.append({
                    "id": site.id,
                    "name": site.name,
                    "new_risk_score": new_risk_score,
                    "vulnerability_score": vulnerability_score,
                    "flood_zone": zones.get("flood_zone", "inconnue"),
                    "earthquake_zone": zones.get("earthquake_zone", "inconnue"),
                    "wind_zone": zones.get("wind_zone", "inconnue"),
                    "subsidence_zone": zones.get("subsidence_zone", "inconnue")
                })
                
            except Exception as e:
                print(f"Erreur lors de la mise à jour du site {site.id}: {e}")
                continue
        
        # Commiter les changements
        db.commit()
        
        return {
            "message": f"Mise à jour terminée pour {len(updated_sites)} sites",
            "updated_sites": updated_sites
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erreur lors de la mise à jour des scores: {str(e)}"
        )

@router.get("/statistics")
async def get_vulnerability_statistics(db: Session = Depends(get_db)):
    """Obtenir des statistiques sur les vulnérabilités"""
    from app.models.site import Site
    
    try:
        sites = db.query(Site).all()
        
        if not sites:
            return {
                "total_sites": 0,
                "average_vulnerability_risk": 0,
                "risk_distribution": {},
                "high_vulnerability_sites": 0,
                "zone_distribution": {}
            }
        
        # Analyser les vulnérabilités pour tous les sites
        vulnerability_risks = []
        zone_distribution = {
            "flood_zones": {"faible": 0, "modérée": 0, "élevée": 0},
            "earthquake_zones": {"faible": 0, "modérée": 0, "élevée": 0},
            "wind_zones": {"faible": 0, "modérée": 0, "élevée": 0},
            "subsidence_zones": {"faible": 0, "modérée": 0, "élevée": 0}
        }
        
        for site in sites:
            try:
                vulnerability_risk = await vulnerability_service.get_vulnerability_risk_for_site(
                    site.latitude,
                    site.longitude,
                    site.building_type.value,
                    site.building_value
                )
                
                risk_score = vulnerability_risk.get("vulnerability_risk", {}).get("vulnerability_risk_score", 25.0)
                vulnerability_risks.append(risk_score)
                
                # Compter les zones de vulnérabilité
                zones = vulnerability_risk.get("vulnerability_risk", {}).get("zone_assessments", {})
                
                for zone_type in ["flood_zones", "earthquake_zones", "wind_zones", "subsidence_zones"]:
                    zone_key = zone_type.replace("_zones", "_zone")
                    zone_value = zones.get(zone_key, "inconnue")
                    if zone_value in ["faible", "modérée", "élevée"]:
                        zone_distribution[zone_type][zone_value] += 1
                    
            except Exception as e:
                print(f"Erreur lors de l'analyse du site {site.id}: {e}")
                continue
        
        if vulnerability_risks:
            avg_risk = sum(vulnerability_risks) / len(vulnerability_risks)
            high_vulnerability_count = len([r for r in vulnerability_risks if r > 50])
            
            risk_distribution = {
                "faible": len([r for r in vulnerability_risks if r < 25]),
                "modéré": len([r for r in vulnerability_risks if 25 <= r < 50]),
                "élevé": len([r for r in vulnerability_risks if 50 <= r < 75]),
                "très élevé": len([r for r in vulnerability_risks if r >= 75])
            }
        else:
            avg_risk = 0
            high_vulnerability_count = 0
            risk_distribution = {"faible": 0, "modéré": 0, "élevé": 0, "très élevé": 0}
        
        return {
            "total_sites": len(sites),
            "average_vulnerability_risk": round(avg_risk, 2),
            "risk_distribution": risk_distribution,
            "high_vulnerability_sites": high_vulnerability_count,
            "zone_distribution": zone_distribution
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erreur lors du calcul des statistiques: {str(e)}"
        )

@router.get("/zone-analysis/{site_id}")
async def get_detailed_zone_analysis(site_id: int, db: Session = Depends(get_db)):
    """Obtenir une analyse détaillée des zones de vulnérabilité pour un site"""
    from app.models.site import Site
    
    site = db.query(Site).filter(Site.id == site_id).first()
    if not site:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Site non trouvé"
        )
    
    try:
        vulnerability_risk = await vulnerability_service.get_vulnerability_risk_for_site(
            site.latitude,
            site.longitude,
            site.building_type.value,
            site.building_value
        )
        
        jba_data = vulnerability_risk.get("jba_data", {})
        fema_data = vulnerability_risk.get("fema_data", {})
        risk_assessment = vulnerability_risk.get("vulnerability_risk", {})
        
        # Analyser chaque type de vulnérabilité
        zone_analysis = {
            "flood": {
                "risk_level": risk_assessment.get("zone_assessments", {}).get("flood_zone", "inconnue"),
                "probability": jba_data.get("flood_risk", {}).get("probability", 0),
                "depth": jba_data.get("flood_risk", {}).get("depth", 0),
                "frequency": jba_data.get("flood_risk", {}).get("frequency", "inconnue"),
                "impact": fema_data.get("natural_hazards", {}).get("flood", {}).get("impact", "inconnu")
            },
            "earthquake": {
                "risk_level": risk_assessment.get("zone_assessments", {}).get("earthquake_zone", "inconnue"),
                "probability": jba_data.get("earthquake_risk", {}).get("probability", 0),
                "magnitude": jba_data.get("earthquake_risk", {}).get("magnitude", 0),
                "frequency": jba_data.get("earthquake_risk", {}).get("frequency", "inconnue"),
                "impact": fema_data.get("natural_hazards", {}).get("earthquake", {}).get("impact", "inconnu")
            },
            "wind": {
                "risk_level": risk_assessment.get("zone_assessments", {}).get("wind_zone", "inconnue"),
                "probability": jba_data.get("wind_risk", {}).get("probability", 0),
                "speed": jba_data.get("wind_risk", {}).get("speed", 0),
                "frequency": jba_data.get("wind_risk", {}).get("frequency", "inconnue"),
                "impact": fema_data.get("natural_hazards", {}).get("hurricane", {}).get("impact", "inconnu")
            },
            "subsidence": {
                "risk_level": risk_assessment.get("zone_assessments", {}).get("subsidence_zone", "inconnue"),
                "probability": jba_data.get("subsidence_risk", {}).get("probability", 0),
                "severity": jba_data.get("subsidence_risk", {}).get("severity", "inconnue"),
                "frequency": jba_data.get("subsidence_risk", {}).get("frequency", "inconnue")
            }
        }
        
        return {
            "site_id": site_id,
            "site_name": site.name,
            "location": f"{site.city}, {site.country}",
            "coordinates": {
                "latitude": site.latitude,
                "longitude": site.longitude
            },
            "vulnerability_score": risk_assessment.get("vulnerability_risk_score", 25.0),
            "zone_analysis": zone_analysis,
            "risk_factors": risk_assessment.get("risk_factors", {}),
            "data_sources": {
                "jba_data_available": bool(jba_data),
                "fema_data_available": bool(fema_data)
            }
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erreur lors de l'analyse des zones: {str(e)}"
        ) 